import streamlit as st
import os
import json
import re
from datetime import datetime
from typing import Any, Dict, List, Tuple, Optional

# =============================================================================
# CONFIG
# =============================================================================
st.set_page_config(page_title="Ice Cream App", layout="wide")

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

RECIPES_PATH   = os.path.join(BASE_DIR, "recipes.json")
LINEUP_FILE    = os.path.join(BASE_DIR, "weekly_lineup.json")
INVENTORY_FILE = os.path.join(BASE_DIR, "inventory.json")               # flavor inventory
INGREDIENT_FILE = os.path.join(BASE_DIR, "ingredient_inventory.json")   # ingredient inventory
THRESHOLD_FILE  = os.path.join(BASE_DIR, "ingredient_thresholds.json")  # mins + units
EXCLUDE_FILE    = os.path.join(BASE_DIR, "excluded_ingredients.json")

UNIT_OPTIONS = ["cans", "50lbs bags", "grams", "liters", "gallons"]  # for thresholds page


# =============================================================================
# GENERIC JSON HELPERS (single definitions)
# =============================================================================
def load_json(path: str, default: Any):
    if not os.path.exists(path):
        return default
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        # Return default but also show a helpful message if we're in Streamlit
        st.error(f"âŒ JSON file is invalid: {os.path.basename(path)}")
        st.caption(f"Error: {e.msg} at line {e.lineno}, column {e.colno} (char {e.pos})")

        # show a small snippet around the error if possible
        try:
            with open(path, "r", encoding="utf-8") as f:
                text = f.read()
            start = max(0, e.pos - 120)
            end = min(len(text), e.pos + 120)
            snippet = text[start:end].replace("\n", "\\n")
            st.code(snippet, language="text")
        except Exception:
            pass

        st.info(
            "Fix your JSON (common issues: trailing commas, comments, missing quotes). "
            "After fixing, rerun the app."
        )
        return default
    except Exception as e:
        st.error(f"âŒ Failed reading {os.path.basename(path)}: {e}")
        return default


def save_json(path: str, data: Any):
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def file_mtime(path: str) -> float:
    try:
        return os.path.getmtime(path)
    except FileNotFoundError:
        return 0.0


# =============================================================================
# RECIPE LOADING (safe + cache-bust)
# =============================================================================
@st.cache_data(ttl=60)
def load_recipes_cached(path: str, mtime: float) -> Dict[str, Any]:
    # mtime is only used to bust cache when file changes
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def load_recipes_safe(path: str) -> Dict[str, Any]:
    if not os.path.exists(path):
        st.error(f"Missing recipes file: {path}")
        st.info("Fix: add recipes.json next to app.py, or update RECIPES_PATH.")
        st.stop()

    # First: try strict json load inside cached function
    mtime = file_mtime(path)
    try:
        recipes = load_recipes_cached(path, mtime)
    except json.JSONDecodeError as e:
        # Show useful error details (Streamlit normally redacts)
        st.error("âŒ recipes.json is not valid JSON.")
        st.caption(f"{e.msg} at line {e.lineno}, column {e.colno} (char {e.pos})")
        try:
            with open(path, "r", encoding="utf-8") as f:
                text = f.read()
            start = max(0, e.pos - 200)
            end = min(len(text), e.pos + 200)
            st.code(text[start:end], language="text")
        except Exception:
            pass
        st.stop()
    except Exception as e:
        st.error(f"âŒ Could not load recipes.json: {e}")
        st.stop()

    if not isinstance(recipes, dict):
        st.error("recipes.json must be a JSON object: {\"Recipe name\": { ... }, ... }")
        st.stop()

    return recipes


# =============================================================================
# RECIPE SCHEMA NORMALIZATION
# =============================================================================
def normalize_recipes_schema(recipes: Dict[str, Any]) -> Dict[str, Any]:
    """
    Ensures each recipe has:
      - ingredients: dict
      - instruction: list[str]
      - subrecipes: dict[str, recipe]
    """
    for name, r in list(recipes.items()):
        if not isinstance(r, dict):
            continue

        r.setdefault("ingredients", {})
        if not isinstance(r["ingredients"], dict):
            r["ingredients"] = {}

        instr = r.get("instruction", [])
        if instr is None:
            instr = []
        elif isinstance(instr, str):
            instr = [instr]
        elif not isinstance(instr, list):
            instr = []
        r["instruction"] = instr

        r.setdefault("subrecipes", {})
        if not isinstance(r["subrecipes"], dict):
            r["subrecipes"] = {}

        # normalize subrecipes recursively (one level deep)
        for sname, s in r["subrecipes"].items():
            if not isinstance(s, dict):
                continue
            s.setdefault("ingredients", {})
            if not isinstance(s["ingredients"], dict):
                s["ingredients"] = {}

            sinstr = s.get("instruction", [])
            if sinstr is None:
                sinstr = []
            elif isinstance(sinstr, str):
                sinstr = [sinstr]
            elif not isinstance(sinstr, list):
                sinstr = []
            s["instruction"] = sinstr

            s.setdefault("subrecipes", {})
            if not isinstance(s["subrecipes"], dict):
                s["subrecipes"] = {}

    return recipes


# =============================================================================
# DISPLAY HELPERS (ingredients + instructions + subrecipes)
# =============================================================================
def render_ingredients_block(ingredients: Dict[str, Any]):
    if not ingredients:
        return

    st.markdown("### ðŸ“‹ Ingredients")

    G_PER_GALLON_MILK = 3785  # your preferred approximation

    for k, v in ingredients.items():
        try:
            grams = float(v)
        except Exception:
            st.write(f"- {k}: {v}")
            continue

        grams_int = int(round(grams))
        line = f"- {k}: {grams_int} g"

        if k.lower() == "milk":
            whole_gal = grams_int // G_PER_GALLON_MILK
            rem_g = grams_int - whole_gal * G_PER_GALLON_MILK
