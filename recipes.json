import os
import json
import re
from datetime import datetime
from typing import Any, Dict

import streamlit as st


# =========================
# Paths / Files
# =========================
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

RECIPES_PATH   = os.path.join(BASE_DIR, "recipes.json")
LINEUP_FILE    = os.path.join(BASE_DIR, "weekly_lineup.json")
FLAVOR_INV_FILE = os.path.join(BASE_DIR, "inventory.json")

INGREDIENT_FILE = os.path.join(BASE_DIR, "ingredient_inventory.json")
THRESHOLD_FILE  = os.path.join(BASE_DIR, "ingredient_thresholds.json")
EXCLUDE_FILE    = os.path.join(BASE_DIR, "excluded_ingredients.json")


# =========================
# Utilities
# =========================
def _slugify(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "_", (s or "").lower()).strip("_") or "x"


def load_json(path: str, default):
    if not os.path.exists(path):
        return default
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default


def save_json(path: str, data):
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def _recipes_mtime(path: str) -> float:
    try:
        return os.path.getmtime(path)
    except FileNotFoundError:
        return 0.0


@st.cache_data(ttl=60)
def load_recipes(path: str, mtime: float) -> dict:
    # mtime is ONLY here to bust cache when file changes
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def normalize_recipes_schema(recipes: dict) -> dict:
    """Ensure each recipe has ingredients (dict), instruction (list), subrecipes (dict)."""
    if not isinstance(recipes, dict):
        return {}

    for _, r in list(recipes.items()):
        if not isinstance(r, dict):
            continue

        r.setdefault("ingredients", {})
        if not isinstance(r["ingredients"], dict):
            r["ingredients"] = {}

        instr = r.get("instruction", [])
        if instr is None:
            instr = []
        elif isinstance(instr, str):
            instr = [instr]
        elif not isinstance(instr, list):
            instr = []
        r["instruction"] = instr

        r.setdefault("subrecipes", {})
        if not isinstance(r["subrecipes"], dict):
            r["subrecipes"] = {}

        for _, s in r["subrecipes"].items():
            if not isinstance(s, dict):
                continue
            s.setdefault("ingredients", {})
            if not isinstance(s["ingredients"], dict):
                s["ingredients"] = {}
            sinstr = s.get("instruction", [])
            if sinstr is None:
                sinstr = []
            elif isinstance(sinstr, str):
                sinstr = [sinstr]
            elif not isinstance(sinstr, list):
                sinstr = []
            s["instruction"] = sinstr

    return recipes


def get_all_ingredients_from_recipes(recipes: Dict[str, Any]) -> list[str]:
    """Includes recipe ingredients + all subrecipe ingredients."""
    names = set()
    for r in (recipes or {}).values():
        if not isinstance(r, dict):
            continue
        for ing in (r.get("ingredients") or {}).keys():
            names.add(str(ing).strip())
        for sub in (r.get("subrecipes") or {}).values():
            if not isinstance(sub, dict):
                continue
            for ing in (sub.get("ingredients") or {}).keys():
                names.add(str(ing).strip())
    return sorted({n for n in names if n})


# =========================
# Threshold / Inventory Schema
# =========================
UNIT_OPTIONS = ["grams", "gallons", "liters", "cans", "50lbs bags", "cases", "other"]

def normalize_thresholds_schema(thresholds: Dict[str, Any]) -> Dict[str, Any]:
    """Upgrade old schema (value-only) to {'min': number, 'unit': 'grams'}."""
    upgraded = {}
    for ing, val in (thresholds or {}).items():
        if isinstance(val, dict):
            min_val = val.get("min", 0.0)
            unit = val.get("unit", "grams")
            if unit not in UNIT_OPTIONS:
                unit = "grams"
            upgraded[ing] = {"min": float(min_val or 0.0), "unit": unit}
        else:
            upgraded[ing] = {"min": float(val or 0.0), "unit": "grams"}
    return upgraded


def normalize_inventory_schema(raw: Dict[str, Any]) -> tuple[Dict[str, Any], bool]:
    """
    Inventory schema: {ingredient: {"amount": float, "unit": str}}
    If file contains numbers (old schema), convert to dict schema.
    """
    inv, changed = {}, False
    for ing, v in (raw or {}).items():
        if isinstance(v, dict):
            amt = float(v.get("amount", 0.0) or 0.0)
            unit = str(v.get("unit", "grams") or "grams")
        else:
            amt = float(v or 0.0)
            unit = "grams"
            changed = True
        inv[str(ing)] = {"amount": amt, "unit": unit}
    return inv, changed


# =========================
# UI helpers
# =========================
def render_ingredients_block(ingredients: dict):
    if not ingredients:
        st.info("No ingredients.")
        return

    st.markdown("### üìã Ingredients")
    for k, v in ingredients.items():
        try:
            grams = float(v)
            grams_int = int(round(grams))
            st.write(f"- {k}: {grams_int} g")
        except Exception:
            st.write(f"- {k}: {v}")


def _render_instructions_block(title: str, steps: list[str]):
    if not steps:
        return
    with st.expander(title, expanded=True):
        for line in steps:
            st.markdown(f"- {line}")


def _render_subrecipes(subrecipes: dict):
    if not subrecipes:
        return
    st.markdown("### üß© Sub-recipes")
    for sname, srec in subrecipes.items():
        if not isinstance(srec, dict):
            continue
        with st.expander(f"Subrecipe: {sname}", expanded=False):
            ings = srec.get("ingredients", {})
            if ings:
                st.markdown("**Ingredients**")
                for k, v in ings.items():
                    try:
                        st.write(f"- {k}: {int(round(float(v)))} g")
                    except Exception:
                        st.write(f"- {k}: {v}")
            _render_instructions_block("Instructions", srec.get("instruction", []))


def make_scaled_recipe(base_recipe: dict, new_ingredients: dict) -> dict:
    return {
        "ingredients": new_ingredients or {},
        "instruction": base_recipe.get("instruction", []) or [],
        "subrecipes": base_recipe.get("subrecipes", {}) or {},
    }


def show_scaled_result(selected_name: str, scaled_ingredients: dict, recipes_dict: dict):
    base = recipes_dict.get(selected_name, {}) or {}
    rec = make_scaled_recipe(base, scaled_ingredients)

    render_ingredients_block(rec.get("ingredients", {}))
    _render_instructions_block("üõ†Ô∏è Instructions", rec.get("instruction", []))
    _render_subrecipes(rec.get("subrecipes", {}))


# =========================
# Pages
# =========================
def page_batching_system(recipes: dict):
    st.header("Batching System")

    recipe_names = sorted(recipes.keys())
    if not recipe_names:
        st.error("No recipes found.")
        return

    # Stable selection
    cur = st.session_state.get("selected_recipe")
    if cur not in recipe_names:
        cur = recipe_names[0]
        st.session_state["selected_recipe"] = cur

    selected_name = st.selectbox(
        "Choose a recipe",
        recipe_names,
        index=recipe_names.index(cur),
        key="selected_recipe",
    )

    rec = recipes.get(selected_name, {}) or {}
    base_ings = rec.get("ingredients", {}) or {}
    original_weight = float(sum([float(x) for x in base_ings.values()]) or 0.0)

    # ------- Scaling UI -------
    st.subheader("Scale")

    scope = "main"
    ns = f"scale__{scope}__{_slugify(selected_name)}"
    def k(s: str) -> str:
        return f"{ns}__{s}"

    # Clear stale scale state when recipe changes
    if st.session_state.get("prev_recipe_for_scale") != selected_name:
        for key in list(st.session_state.keys()):
            if isinstance(key, str) and key.startswith("scale__"):
                st.session_state.pop(key)
        st.session_state["prev_recipe_for_scale"] = selected_name

    scale_mode = st.radio(
        "Method",
        [
            "Target batch weight (g)",
            "Multiplier x",
        ],
        horizontal=True,
        key=k("mode"),
    )

    scale_factor = 1.0
    info_lines = []

    if scale_mode == "Target batch weight (g)":
        target_weight = st.number_input(
            "Target weight (g)",
            min_value=1.0,
            value=float(original_weight or 1000.0),
            step=100.0,
            key=k("target_weight"),
        )
        scale_factor = (target_weight / original_weight) if original_weight else 1.0
        info_lines.append(f"Target weight: {target_weight:,.0f} g")
    else:
        scale_factor = st.number_input(
            "Multiplier",
            min_value=0.01,
            value=1.0,
            step=0.1,
            key=k("multiplier"),
        )
        info_lines.append(f"Scale factor: √ó{scale_factor:.3f}")

    scaled = {ing: round(float(qty) * float(scale_factor), 2) for ing, qty in base_ings.items()}
    total_scaled = round(sum([float(x) for x in scaled.values()]) or 0.0, 2)

    st.metric("Total batch weight (g)", f"{total_scaled:,.2f}")
    for line in info_lines:
        st.caption(line)

    show_scaled_result(selected_name, scaled, recipes)

    # ------- Step-by-step execution -------
    st.subheader("Execute batch (step-by-step)")
    key_prefix = f"bs_{_slugify(selected_name)}"

    step_key = f"{key_prefix}_step"
    order_key = f"{key_prefix}_order"

    if step_key not in st.session_state:
        st.session_state[step_key] = None
    if order_key not in st.session_state or not isinstance(st.session_state[order_key], list):
        st.session_state[order_key] = list(scaled.keys())

    if st.button("‚ñ∂Ô∏è Start batch", key=f"{key_prefix}_start"):
        st.session_state[step_key] = 0
        st.session_state[order_key] = list(scaled.keys())

    step = st.session_state[step_key]
    order = st.session_state[order_key]

    if step is not None:
        if step < len(order):
            ing = order[step]
            grams = float(scaled.get(ing, 0.0))
            st.info(f"**{ing} {grams:.0f} grams**")

            c1, c2, c3 = st.columns(3)

            with c1:
                st.button(
                    "‚¨ÖÔ∏è Back",
                    key=f"{key_prefix}_back",
                    disabled=(step == 0),
                    on_click=lambda: st.session_state.update({step_key: max(0, step - 1)}),
                )
            with c2:
                st.button(
                    "‚èπ Reset",
                    key=f"{key_prefix}_reset",
                    on_click=lambda: st.session_state.update({step_key: None}),
                )
            with c3:
                st.button(
                    "Next ‚û°Ô∏è",
                    key=f"{key_prefix}_next",
                    on_click=lambda: st.session_state.update({step_key: step + 1}),
                )
        else:
            st.success("‚úÖ Batch complete")
            st.button(
                "Start over",
                key=f"{key_prefix}_restart",
                on_click=lambda: st.session_state.update({step_key: 0}),
            )


def page_flavor_inventory(recipes: dict):
    st.header("Flavor Inventory")

    lineup = load_json(LINEUP_FILE, [])
    inv = load_json(FLAVOR_INV_FILE, {})

    st.subheader("1) Weekly lineup")
    lineup_input = st.text_area("Flavors (comma-separated)", value=", ".join(lineup), key="lineup_input")
    if st.button("Update Lineup", key="update_lineup_btn"):
        lineup = [x.strip() for x in lineup_input.split(",") if x.strip()]
        # keep only lineup flavors
        inv = {k: v for k, v in inv.items() if k in lineup}
        save_json(LINEUP_FILE, lineup)
        save_json(FLAVOR_INV_FILE, inv)
        st.success("‚úÖ Lineup updated.")

    st.subheader("2) Update inventory")
    if not lineup:
        st.info("Set a weekly lineup first.")
        return

    flavor = st.selectbox("Flavor", lineup, key="fi_flavor")
    quarts = st.number_input("Quarts", min_value=0.0, step=1.0, value=0.0, key="fi_quarts")

    if st.button("Submit", key="fi_submit"):
        inv[flavor] = {"quarts": quarts, "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M")}
        save_json(FLAVOR_INV_FILE, inv)
        st.success(f"‚úÖ Updated {flavor}")

    st.subheader("3) Current inventory")
    if inv:
        st.dataframe(
            {
                "Flavor": list(inv.keys()),
                "Quarts": [inv[k].get("quarts", 0) for k in inv.keys()],
                "Last Updated": [inv[k].get("last_updated", "") for k in inv.keys()],
            },
            use_container_width=True,
        )
    else:
        st.info("No inventory records yet.")


def page_set_min_inventory(recipes: dict):
    st.header("Set Minimum Inventory Levels")

    all_ingredients = get_all_ingredients_from_recipes(recipes)
    if not all_ingredients:
        st.info("No ingredients found in recipes.")
        return

    thresholds_raw = load_json(THRESHOLD_FILE, {})
    thresholds = normalize_thresholds_schema(thresholds_raw)

    edited: Dict[str, Any] = {}

    st.caption("Set minimum levels + units. Units are informational (no conversion applied).")

    for ing in all_ingredients:
        cur_min = float((thresholds.get(ing, {}) or {}).get("min", 0.0) or 0.0)
        cur_unit = (thresholds.get(ing, {}) or {}).get("unit", "grams")
        if cur_unit not in UNIT_OPTIONS:
            cur_unit = "grams"

        c1, c2, c3 = st.columns([3, 2, 2])
        c1.write(ing)
        new_min = c2.number_input(
            f"min_{ing}",
            value=cur_min,
            min_value=0.0,
            step=1.0,
            format="%.2f",
            label_visibility="collapsed",
        )
        new_unit = c3.selectbox(
            f"unit_{ing}",
            options=UNIT_OPTIONS,
            index=UNIT_OPTIONS.index(cur_unit),
            label_visibility="collapsed",
        )
        edited[ing] = {"min": new_min, "unit": new_unit}

    if st.button("üíæ Save Minimums & Units", type="primary"):
        save_json(THRESHOLD_FILE, edited)
        st.success("‚úÖ Saved.")


def page_ingredient_inventory(recipes: dict):
    st.header("Ingredient Inventory")

    all_ingredients = get_all_ingredients_from_recipes(recipes)
    excluded = load_json(EXCLUDE_FILE, [])
    exclude_list = st.multiselect(
        "Exclude ingredients",
        all_ingredients,
        default=[e for e in excluded if e in all_ingredients],
        key="exclude_list",
    )
    if st.button("Save Exclusion List"):
        save_json(EXCLUDE_FILE, exclude_list)
        st.success("‚úÖ Exclusions saved.")

    thresholds = normalize_thresholds_schema(load_json(THRESHOLD_FILE, {}))

    raw_inv = load_json(INGREDIENT_FILE, {})
    inv, changed = normalize_inventory_schema(raw_inv)
    if changed:
        save_json(INGREDIENT_FILE, inv)

    # Ensure all ingredients exist
    for ing in all_ingredients:
        inv.setdefault(ing, {"amount": 0.0, "unit": thresholds.get(ing, {}).get("unit", "grams")})

    # Filter
    q = st.text_input("Filter", "", key="ii_filter").strip().lower()

    edited = {}
    for ing in all_ingredients:
        if ing in exclude_list:
            continue
        if q and q not in ing.lower():
            continue

        unit_hint = thresholds.get(ing, {}).get("unit", "grams")
        cur_amt = float(inv.get(ing, {}).get("amount", 0.0) or 0.0)
        cur_unit = inv.get(ing, {}).get("unit", unit_hint) or unit_hint

        col1, col2 = st.columns([3, 2])
        with col1:
            amt = st.number_input(
                f"{ing} ({unit_hint})",
                min_value=0.0,
                value=cur_amt,
                step=1.0,
                key=f"inv_amt_{ing}",
            )
        with col2:
            unit = st.selectbox(
                "Unit",
                options=UNIT_OPTIONS,
                index=UNIT_OPTIONS.index(cur_unit) if cur_unit in UNIT_OPTIONS else UNIT_OPTIONS.index(unit_hint if unit_hint in UNIT_OPTIONS else "grams"),
                key=f"inv_unit_{ing}",
                label_visibility="visible",
            )

        edited[ing] = {"amount": amt, "unit": unit}

    if st.button("üíæ Save ingredient inventory"):
        inv.update(edited)
        save_json(INGREDIENT_FILE, inv)
        st.success("‚úÖ Saved.")

    # Reorder check
    st.subheader("Ingredients needing reorder")
    needs = {}
    for ing, th in thresholds.items():
        if ing in exclude_list:
            continue
        if ing not in inv:
            continue
        amt = float(inv[ing].get("amount", 0.0) or 0.0)
        min_level = float(th.get("min", 0.0) or 0.0)
        unit = th.get("unit", inv[ing].get("unit", "grams"))
        if amt < min_level:
            needs[ing] = f"{amt} {unit} < {min_level} {unit}"

    if needs:
        st.error("‚ö†Ô∏è Order needed")
        st.dataframe(needs, use_container_width=True)
    else:
        st.success("‚úÖ All ingredients above minimum thresholds.")


# =========================
# Main App
# =========================
st.set_page_config(page_title="Icecream App", layout="wide")

# Load recipes.json (single source of truth)
if not os.path.exists(RECIPES_PATH):
    st.error(f"Missing recipes file: {RECIPES_PATH}")
    st.stop()

mtime = _recipes_mtime(RECIPES_PATH)
try:
    recipes = load_recipes(RECIPES_PATH, mtime)
except json.JSONDecodeError as e:
    st.error(f"recipes.json is invalid JSON at line {e.lineno}, column {e.colno}.")
    st.stop()

recipes = normalize_recipes_schema(recipes)

# Sidebar navigation
page = st.sidebar.radio(
    "Go to",
    ["Batching System", "Flavor Inventory", "Ingredient Inventory", "Set Min Inventory"],
    key="sidebar_nav",
)

if page == "Batching System":
    page_batching_system(recipes)
elif page == "Flavor Inventory":
    page_flavor_inventory(recipes)
elif page == "Ingredient Inventory":
    page_ingredient_inventory(recipes)
else:
    page_set_min_inventory(recipes)
